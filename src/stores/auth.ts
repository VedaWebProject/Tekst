import { ref, computed } from 'vue';
import { defineStore } from 'pinia';
import type { ErrorModel, UserRead, UserUpdate } from '@/openapi';
import { useMessages } from '@/messages';
import { useApi } from '@/api';
import { i18n, localeProfiles } from '@/i18n';
import { useIntervalFn } from '@vueuse/core';
import { useRouter, type RouteLocationRaw } from 'vue-router';
import type { AxiosError } from 'axios';
import { createTemplatePromise } from '@vueuse/core';
import { usePlatformData } from '@/platformData';
import { useStateStore } from '@/stores';

const SESSION_POLL_INTERVAL_S = 60; // check session expiry every n seconds
const SESSION_EXPIRY_OFFSET_S = 10; // assume session expired n seconds early
const SESSION_WARN_AHEAD_S = 600; // start showing warnings n seconds before expiry

function getUserFromLocalStorage(): UserRead | null {
  const storageData = localStorage.getItem('user');
  if (!storageData) return null;
  return JSON.parse(storageData) as UserRead;
}

const { pause: _stopSessionCheck, resume: _startSessionCheck } = useIntervalFn(
  () => {
    const { checkSession } = useAuthStore();
    checkSession();
  },
  SESSION_POLL_INTERVAL_S * 1000,
  { immediate: true, immediateCallback: false }
);

export const LoginTemplatePromise = createTemplatePromise<
  // promise resolve type
  boolean,
  // extra args
  [
    // login modal message
    string | undefined,
    // route to change to after login
    RouteLocationRaw | undefined,
    // display register button
    boolean
  ]
>();

export const useAuthStore = defineStore('auth', () => {
  const router = useRouter();
  const { pfData } = usePlatformData();
  const { message } = useMessages();
  const { authApi, usersApi } = useApi();
  const { t } = i18n.global;
  const state = useStateStore();

  const user = ref<UserRead | null>(getUserFromLocalStorage());
  const loggedIn = computed(() => !!user.value);

  const sessionExpiryTsSec = ref(
    Number(localStorage.getItem('sessionExpiryS') || Number.MAX_SAFE_INTEGER)
  );

  function _setCookieExpiry() {
    sessionExpiryTsSec.value =
      Date.now() / 1000 +
      (pfData.value?.security?.authCookieLifetime || 0) -
      SESSION_EXPIRY_OFFSET_S;
    localStorage.setItem('sessionExpiryS', String(sessionExpiryTsSec.value));
  }

  function _unsetCookieExpiry() {
    sessionExpiryTsSec.value = Number.MAX_SAFE_INTEGER;
    localStorage.removeItem('sessionExpiryS');
  }

  async function _renewExpiredSession() {
    message.warning(t('account.sessionExpired'));
    _cleanupSession();
    if (!(await showLoginModal(t('account.renewLogin'), router.currentRoute.value, false))) {
      router.push({ name: 'home' });
    }
  }

  function _cleanupSession() {
    user.value = null;
    localStorage.removeItem('user');
    _unsetCookieExpiry();
    _stopSessionCheck();
  }

  function _sessionExpiresInS() {
    return sessionExpiryTsSec.value - Date.now() / 1000;
  }

  function checkSession() {
    const timeLeftS = _sessionExpiresInS();
    if (timeLeftS <= 0) {
      _renewExpiredSession();
      return;
    } else if (timeLeftS <= SESSION_WARN_AHEAD_S) {
      const minutes = Math.floor(timeLeftS / 60);
      const seconds = Math.round(timeLeftS % 60);
      message.warning(t('account.autoLogout', { minutes, seconds }), 30);
    }
  }

  async function showLoginModal(
    message: string | undefined = undefined,
    nextRoute: RouteLocationRaw = { name: 'home' },
    showRegisterLink: boolean = true
  ) {
    try {
      return await LoginTemplatePromise.start(message, nextRoute, showRegisterLink);
    } catch {
      return false;
    }
  }

  async function login(
    username: string,
    password: string,
    nextRoute: RouteLocationRaw | null | undefined
  ) {
    try {
      await authApi.authCookieLogin({ username, password }, { headers: { is_login: true } });
      _setCookieExpiry();
      _startSessionCheck();
      const userData = (await usersApi.usersCurrentUser()).data;
      userData && localStorage.setItem('user', JSON.stringify(userData));
      user.value = userData;
      // process user locale
      if (!userData.locale) {
        try {
          updateUser({ locale: localeProfiles[state.locale].apiLocaleEnum });
        } catch {
          // just let it happen
        }
      } else {
        await state.setLocale(userData.locale, false);
      }
      message.success(t('general.welcome', { name: userData.firstName }));
      nextRoute && router.push(nextRoute);
      return true;
    } catch (e) {
      /**
       * Unfortunately, the errors returned by the endpoints generated by
       * FastAPI-Users have a weird custom model that we have to handle here...
       */
      const error = e as AxiosError;
      if (error.response) {
        const data = error.response.data as ErrorModel;
        if (data.detail === 'LOGIN_BAD_CREDENTIALS') {
          message.error(t('account.errors.badCreds'));
        } else if (data.detail === 'LOGIN_USER_NOT_VERIFIED') {
          authApi
            .verifyRequestToken({
              bodyVerifyRequestTokenAuthRequestVerifyTokenPost: { email: username },
            })
            .then(() => {
              message.error(t('account.errors.notVerified'));
            })
            .catch(() => {
              message.error(t('errors.unexpected'));
            });
        } else if (error.response.status === 403) {
          message.error(t('errors.csrf'));
        } else {
          message.error(t('errors.unexpected'));
        }
      } else {
        message.error(t('errors.unexpected'));
      }
      _cleanupSession();
      return false;
    }
  }

  async function logout() {
    try {
      await authApi.authCookieLogout();
      message.success(t('account.logoutSuccessful'));
    } catch {
      // do sweet FA
    } finally {
      _cleanupSession();
      router.push({ name: 'home' });
    }
  }

  async function updateUser(userUpdate: UserUpdate) {
    if (!user.value) return Promise.reject('no user');
    const updatedUser = await usersApi
      .usersPatchCurrentUser({ userUpdate })
      .then((response) => response.data);
    if (updatedUser) {
      user.value = updatedUser;
      localStorage.setItem('user', JSON.stringify(updatedUser));
    }
    return updatedUser;
  }

  return {
    user,
    loggedIn,
    showLoginModal,
    login,
    logout,
    updateUser,
    checkSession,
  };
});
