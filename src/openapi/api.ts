/* tslint:disable */
/* eslint-disable */
/**
 * Tekst-DEV
 * An online text research platform
 *
 * The version of the OpenAPI document: 0.0.1
 * Contact: rick.sanchez@example-tekst-instance.org
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface BearerResponse
 */
export interface BearerResponse {
    /**
     * 
     * @type {string}
     * @memberof BearerResponse
     */
    'access_token': string;
    /**
     * 
     * @type {string}
     * @memberof BearerResponse
     */
    'token_type': string;
}
/**
 * 
 * @export
 * @interface BodyResetForgotPasswordAuthForgotPasswordPost
 */
export interface BodyResetForgotPasswordAuthForgotPasswordPost {
    /**
     * 
     * @type {string}
     * @memberof BodyResetForgotPasswordAuthForgotPasswordPost
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface BodyResetResetPasswordAuthResetPasswordPost
 */
export interface BodyResetResetPasswordAuthResetPasswordPost {
    /**
     * 
     * @type {string}
     * @memberof BodyResetResetPasswordAuthResetPasswordPost
     */
    'token': string;
    /**
     * 
     * @type {string}
     * @memberof BodyResetResetPasswordAuthResetPasswordPost
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface BodyVerifyRequestTokenAuthRequestVerifyTokenPost
 */
export interface BodyVerifyRequestTokenAuthRequestVerifyTokenPost {
    /**
     * 
     * @type {string}
     * @memberof BodyVerifyRequestTokenAuthRequestVerifyTokenPost
     */
    'email': string;
}
/**
 * 
 * @export
 * @interface BodyVerifyVerifyAuthVerifyPost
 */
export interface BodyVerifyVerifyAuthVerifyPost {
    /**
     * 
     * @type {string}
     * @memberof BodyVerifyVerifyAuthVerifyPost
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface DeepLLinksConfig
 */
export interface DeepLLinksConfig {
    /**
     * Enable/disable quick translation links to DeepL
     * @type {boolean}
     * @memberof DeepLLinksConfig
     */
    'enabled'?: boolean;
    /**
     * Source language
     * @type {string}
     * @memberof DeepLLinksConfig
     */
    'sourceLanguage'?: DeepLLinksConfigSourceLanguageEnum;
    /**
     * Target languages to display links for
     * @type {Array<string>}
     * @memberof DeepLLinksConfig
     */
    'languages'?: Array<DeepLLinksConfigLanguagesEnum>;
}

export const DeepLLinksConfigSourceLanguageEnum = {
    Bg: 'BG',
    Cs: 'CS',
    Da: 'DA',
    De: 'DE',
    El: 'EL',
    En: 'EN',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fr: 'FR',
    Hu: 'HU',
    Id: 'ID',
    It: 'IT',
    Ja: 'JA',
    Lt: 'LT',
    Lv: 'LV',
    Nl: 'NL',
    Pl: 'PL',
    Pt: 'PT',
    Ro: 'RO',
    Ru: 'RU',
    Sk: 'SK',
    Sl: 'SL',
    Sv: 'SV',
    Tr: 'TR',
    Uk: 'UK',
    Zh: 'ZH'
} as const;

export type DeepLLinksConfigSourceLanguageEnum = typeof DeepLLinksConfigSourceLanguageEnum[keyof typeof DeepLLinksConfigSourceLanguageEnum];
export const DeepLLinksConfigLanguagesEnum = {
    Bg: 'BG',
    Cs: 'CS',
    Da: 'DA',
    De: 'DE',
    El: 'EL',
    En: 'EN',
    Es: 'ES',
    Et: 'ET',
    Fi: 'FI',
    Fr: 'FR',
    Hu: 'HU',
    Id: 'ID',
    It: 'IT',
    Ja: 'JA',
    Lt: 'LT',
    Lv: 'LV',
    Nl: 'NL',
    Pl: 'PL',
    Pt: 'PT',
    Ro: 'RO',
    Ru: 'RU',
    Sk: 'SK',
    Sl: 'SL',
    Sv: 'SV',
    Tr: 'TR',
    Uk: 'UK',
    Zh: 'ZH'
} as const;

export type DeepLLinksConfigLanguagesEnum = typeof DeepLLinksConfigLanguagesEnum[keyof typeof DeepLLinksConfigLanguagesEnum];

/**
 * 
 * @export
 * @interface Detail
 */
export interface Detail {
}
/**
 * 
 * @export
 * @interface ErrorModel
 */
export interface ErrorModel {
    /**
     * 
     * @type {Detail}
     * @memberof ErrorModel
     */
    'detail': Detail;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface Info
 */
export interface Info {
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    'platformName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    'terms'?: string;
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    'contactName'?: string;
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    'contactUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof Info
     */
    'contactEmail'?: string;
}
/**
 * General information config model
 * @export
 * @interface InfoConfig
 */
export interface InfoConfig {
    /**
     * 
     * @type {string}
     * @memberof InfoConfig
     */
    'platformName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoConfig
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoConfig
     */
    'terms'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoConfig
     */
    'contactName'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoConfig
     */
    'contactUrl'?: string;
    /**
     * 
     * @type {string}
     * @memberof InfoConfig
     */
    'contactEmail'?: string;
}
/**
 * 
 * @export
 * @interface LayerTypeInfo
 */
export interface LayerTypeInfo {
    /**
     * 
     * @type {string}
     * @memberof LayerTypeInfo
     */
    'key': string;
    /**
     * 
     * @type {string}
     * @memberof LayerTypeInfo
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof LayerTypeInfo
     */
    'description': string;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * A node in a text structure (e.g. chapter, paragraph, ...)
 * @export
 * @interface NodeCreate
 */
export interface NodeCreate {
    /**
     * ID of the text this node belongs to
     * @type {string}
     * @memberof NodeCreate
     */
    'textId': string;
    /**
     * ID of parent node
     * @type {string}
     * @memberof NodeCreate
     */
    'parentId'?: string;
    /**
     * Index of structure level this node is on
     * @type {number}
     * @memberof NodeCreate
     */
    'level': number;
    /**
     * Position among all text nodes on this level
     * @type {number}
     * @memberof NodeCreate
     */
    'position': number;
    /**
     * Label for identifying this text node in level context
     * @type {string}
     * @memberof NodeCreate
     */
    'label': string;
    /**
     * Arbitrary metadata
     * @type {{ [key: string]: string; }}
     * @memberof NodeCreate
     */
    'meta'?: { [key: string]: string; };
}
/**
 * A node in a text structure (e.g. chapter, paragraph, ...)
 * @export
 * @interface NodeRead
 */
export interface NodeRead {
    /**
     * 
     * @type {string}
     * @memberof NodeRead
     */
    'id': string;
    /**
     * ID of the text this node belongs to
     * @type {string}
     * @memberof NodeRead
     */
    'textId': string;
    /**
     * ID of parent node
     * @type {string}
     * @memberof NodeRead
     */
    'parentId'?: string;
    /**
     * Index of structure level this node is on
     * @type {number}
     * @memberof NodeRead
     */
    'level': number;
    /**
     * Position among all text nodes on this level
     * @type {number}
     * @memberof NodeRead
     */
    'position': number;
    /**
     * Label for identifying this text node in level context
     * @type {string}
     * @memberof NodeRead
     */
    'label': string;
    /**
     * Arbitrary metadata
     * @type {{ [key: string]: string; }}
     * @memberof NodeRead
     */
    'meta'?: { [key: string]: string; };
}
/**
 * A node in a text structure (e.g. chapter, paragraph, ...)
 * @export
 * @interface NodeUpdate
 */
export interface NodeUpdate {
    /**
     * 
     * @type {string}
     * @memberof NodeUpdate
     */
    'textId'?: string;
    /**
     * 
     * @type {string}
     * @memberof NodeUpdate
     */
    'parentId'?: string;
    /**
     * 
     * @type {number}
     * @memberof NodeUpdate
     */
    'level'?: number;
    /**
     * 
     * @type {number}
     * @memberof NodeUpdate
     */
    'position'?: number;
    /**
     * 
     * @type {string}
     * @memberof NodeUpdate
     */
    'label'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof NodeUpdate
     */
    'meta'?: { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface PlainTextLayerConfig
 */
export interface PlainTextLayerConfig {
    /**
     * 
     * @type {DeepLLinksConfig}
     * @memberof PlainTextLayerConfig
     */
    'deeplLinks'?: DeepLLinksConfig;
}
/**
 * A data layer describing a set of data on a text
 * @export
 * @interface PlainTextLayerCreate
 */
export interface PlainTextLayerCreate {
    /**
     * Title of this layer
     * @type {string}
     * @memberof PlainTextLayerCreate
     */
    'title': string;
    /**
     * Short, one-line description of this data layer
     * @type {string}
     * @memberof PlainTextLayerCreate
     */
    'description'?: string;
    /**
     * ID of the text this layer belongs to
     * @type {string}
     * @memberof PlainTextLayerCreate
     */
    'textId'?: string;
    /**
     * Text level this layer belongs to
     * @type {number}
     * @memberof PlainTextLayerCreate
     */
    'level': number;
    /**
     * A string identifying one of the available layer types
     * @type {string}
     * @memberof PlainTextLayerCreate
     */
    'layerType': string;
    /**
     * User owning this layer
     * @type {string}
     * @memberof PlainTextLayerCreate
     */
    'ownerId'?: string;
    /**
     * Users with shared read access to this layer
     * @type {Array<string>}
     * @memberof PlainTextLayerCreate
     */
    'sharedRead'?: Array<string>;
    /**
     * Users with shared write access to this layer
     * @type {Array<string>}
     * @memberof PlainTextLayerCreate
     */
    'sharedWrite'?: Array<string>;
    /**
     * Publication status of this layer
     * @type {boolean}
     * @memberof PlainTextLayerCreate
     */
    'public'?: boolean;
    /**
     * Arbitrary metadata
     * @type {{ [key: string]: string; }}
     * @memberof PlainTextLayerCreate
     */
    'meta'?: { [key: string]: string; };
    /**
     * Plaintext, potentially multiline comment on this layer
     * @type {string}
     * @memberof PlainTextLayerCreate
     */
    'comment'?: string;
    /**
     * 
     * @type {PlainTextLayerConfig}
     * @memberof PlainTextLayerCreate
     */
    'config'?: PlainTextLayerConfig;
}
/**
 * A data layer describing a set of data on a text
 * @export
 * @interface PlainTextLayerRead
 */
export interface PlainTextLayerRead {
    /**
     * 
     * @type {string}
     * @memberof PlainTextLayerRead
     */
    'id': string;
    /**
     * Title of this layer
     * @type {string}
     * @memberof PlainTextLayerRead
     */
    'title': string;
    /**
     * Short, one-line description of this data layer
     * @type {string}
     * @memberof PlainTextLayerRead
     */
    'description'?: string;
    /**
     * ID of the text this layer belongs to
     * @type {string}
     * @memberof PlainTextLayerRead
     */
    'textId'?: string;
    /**
     * Text level this layer belongs to
     * @type {number}
     * @memberof PlainTextLayerRead
     */
    'level': number;
    /**
     * A string identifying one of the available layer types
     * @type {string}
     * @memberof PlainTextLayerRead
     */
    'layerType': string;
    /**
     * User owning this layer
     * @type {string}
     * @memberof PlainTextLayerRead
     */
    'ownerId'?: string;
    /**
     * Users with shared read access to this layer
     * @type {Array<string>}
     * @memberof PlainTextLayerRead
     */
    'sharedRead'?: Array<string>;
    /**
     * Users with shared write access to this layer
     * @type {Array<string>}
     * @memberof PlainTextLayerRead
     */
    'sharedWrite'?: Array<string>;
    /**
     * Publication status of this layer
     * @type {boolean}
     * @memberof PlainTextLayerRead
     */
    'public'?: boolean;
    /**
     * Arbitrary metadata
     * @type {{ [key: string]: string; }}
     * @memberof PlainTextLayerRead
     */
    'meta'?: { [key: string]: string; };
    /**
     * Plaintext, potentially multiline comment on this layer
     * @type {string}
     * @memberof PlainTextLayerRead
     */
    'comment'?: string;
    /**
     * 
     * @type {PlainTextLayerConfig}
     * @memberof PlainTextLayerRead
     */
    'config'?: PlainTextLayerConfig;
}
/**
 * A data layer describing a set of data on a text
 * @export
 * @interface PlainTextLayerUpdate
 */
export interface PlainTextLayerUpdate {
    /**
     * 
     * @type {string}
     * @memberof PlainTextLayerUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlainTextLayerUpdate
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlainTextLayerUpdate
     */
    'textId'?: string;
    /**
     * 
     * @type {number}
     * @memberof PlainTextLayerUpdate
     */
    'level'?: number;
    /**
     * 
     * @type {string}
     * @memberof PlainTextLayerUpdate
     */
    'layerType'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlainTextLayerUpdate
     */
    'ownerId'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlainTextLayerUpdate
     */
    'sharedRead'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlainTextLayerUpdate
     */
    'sharedWrite'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof PlainTextLayerUpdate
     */
    'public'?: boolean;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PlainTextLayerUpdate
     */
    'meta'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PlainTextLayerUpdate
     */
    'comment'?: string;
    /**
     * 
     * @type {PlainTextLayerConfig}
     * @memberof PlainTextLayerUpdate
     */
    'config'?: PlainTextLayerConfig;
}
/**
 * A unit of a plaintext data layer
 * @export
 * @interface PlainTextUnitCreate
 */
export interface PlainTextUnitCreate {
    /**
     * Data layer ID
     * @type {string}
     * @memberof PlainTextUnitCreate
     */
    'layerId': string;
    /**
     * Parent text node ID
     * @type {string}
     * @memberof PlainTextUnitCreate
     */
    'nodeId': string;
    /**
     * Arbitrary metadata on this layer unit
     * @type {{ [key: string]: string; }}
     * @memberof PlainTextUnitCreate
     */
    'meta'?: { [key: string]: string; };
    /**
     * Text content of the plaintext unit
     * @type {string}
     * @memberof PlainTextUnitCreate
     */
    'text'?: string;
}
/**
 * A unit of a plaintext data layer
 * @export
 * @interface PlainTextUnitRead
 */
export interface PlainTextUnitRead {
    /**
     * 
     * @type {string}
     * @memberof PlainTextUnitRead
     */
    'id': string;
    /**
     * Data layer ID
     * @type {string}
     * @memberof PlainTextUnitRead
     */
    'layerId': string;
    /**
     * Parent text node ID
     * @type {string}
     * @memberof PlainTextUnitRead
     */
    'nodeId': string;
    /**
     * Arbitrary metadata on this layer unit
     * @type {{ [key: string]: string; }}
     * @memberof PlainTextUnitRead
     */
    'meta'?: { [key: string]: string; };
    /**
     * Text content of the plaintext unit
     * @type {string}
     * @memberof PlainTextUnitRead
     */
    'text'?: string;
}
/**
 * A unit of a plaintext data layer
 * @export
 * @interface PlainTextUnitUpdate
 */
export interface PlainTextUnitUpdate {
    /**
     * 
     * @type {string}
     * @memberof PlainTextUnitUpdate
     */
    'layerId'?: string;
    /**
     * 
     * @type {string}
     * @memberof PlainTextUnitUpdate
     */
    'nodeId'?: string;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof PlainTextUnitUpdate
     */
    'meta'?: { [key: string]: string; };
    /**
     * 
     * @type {string}
     * @memberof PlainTextUnitUpdate
     */
    'text'?: string;
}
/**
 * Platform data used by the web client
 * @export
 * @interface PlatformData
 */
export interface PlatformData {
    /**
     * 
     * @type {Info}
     * @memberof PlatformData
     */
    'info'?: Info;
    /**
     * 
     * @type {Tekstinfo}
     * @memberof PlatformData
     */
    'tekstInfo'?: Tekstinfo;
    /**
     * 
     * @type {Array<TextRead>}
     * @memberof PlatformData
     */
    'texts': Array<TextRead>;
    /**
     * 
     * @type {PlatformSettingsRead}
     * @memberof PlatformData
     */
    'settings': PlatformSettingsRead;
    /**
     * 
     * @type {PlatformSecurityInfo}
     * @memberof PlatformData
     */
    'security'?: PlatformSecurityInfo;
    /**
     * 
     * @type {Array<LayerTypeInfo>}
     * @memberof PlatformData
     */
    'layerTypes': Array<LayerTypeInfo>;
}
/**
 * 
 * @export
 * @interface PlatformSecurityInfo
 */
export interface PlatformSecurityInfo {
    /**
     * 
     * @type {boolean}
     * @memberof PlatformSecurityInfo
     */
    'usersActiveByDefault'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlatformSecurityInfo
     */
    'usersNeedVerification'?: boolean;
}
/**
 * Settings defining platform behavior configured by admins
 * @export
 * @interface PlatformSettingsRead
 */
export interface PlatformSettingsRead {
    /**
     * 
     * @type {string}
     * @memberof PlatformSettingsRead
     */
    'id': string;
    /**
     * Default text to load in UI
     * @type {string}
     * @memberof PlatformSettingsRead
     */
    'defaultTextId'?: string;
}
/**
 * Settings defining platform behavior configured by admins
 * @export
 * @interface PlatformSettingsUpdate
 */
export interface PlatformSettingsUpdate {
    /**
     * 
     * @type {string}
     * @memberof PlatformSettingsUpdate
     */
    'defaultTextId'?: string;
}
/**
 * Tekst platform information config model  These values are not configurable. They are taken from the package infos and aren\'t meant to be changed by users creating an own instance of the platform.
 * @export
 * @interface TekstInfoConfig
 */
export interface TekstInfoConfig {
    /**
     * 
     * @type {string}
     * @memberof TekstInfoConfig
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof TekstInfoConfig
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof TekstInfoConfig
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof TekstInfoConfig
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof TekstInfoConfig
     */
    'license'?: string;
    /**
     * 
     * @type {string}
     * @memberof TekstInfoConfig
     */
    'licenseUrl'?: string;
}
/**
 * 
 * @export
 * @interface Tekstinfo
 */
export interface Tekstinfo {
    /**
     * 
     * @type {string}
     * @memberof Tekstinfo
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tekstinfo
     */
    'version'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tekstinfo
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tekstinfo
     */
    'website'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tekstinfo
     */
    'license'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tekstinfo
     */
    'licenseUrl'?: string;
}
/**
 * A text represented in Tekst
 * @export
 * @interface TextCreate
 */
export interface TextCreate {
    /**
     * Title of this text
     * @type {string}
     * @memberof TextCreate
     */
    'title': string;
    /**
     * A short identifier for use in URLs and internal operations
     * @type {string}
     * @memberof TextCreate
     */
    'slug': string;
    /**
     * Subtitle of this text
     * @type {string}
     * @memberof TextCreate
     */
    'subtitle'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TextCreate
     */
    'levels': Array<string>;
    /**
     * Default structure level for the client to use for browsing this text
     * @type {number}
     * @memberof TextCreate
     */
    'defaultLevel'?: number;
    /**
     * Delimiter for displaying text locations
     * @type {string}
     * @memberof TextCreate
     */
    'locDelim'?: string;
    /**
     * Whether the UI should label the nodes of the browse location with each levels\' names
     * @type {boolean}
     * @memberof TextCreate
     */
    'labeledLevels'?: boolean;
    /**
     * Accent color used for this text in the client UI
     * @type {string}
     * @memberof TextCreate
     */
    'accentColor'?: string;
}
/**
 * A text represented in Tekst
 * @export
 * @interface TextRead
 */
export interface TextRead {
    /**
     * 
     * @type {string}
     * @memberof TextRead
     */
    'id': string;
    /**
     * Title of this text
     * @type {string}
     * @memberof TextRead
     */
    'title': string;
    /**
     * A short identifier for use in URLs and internal operations
     * @type {string}
     * @memberof TextRead
     */
    'slug': string;
    /**
     * Subtitle of this text
     * @type {string}
     * @memberof TextRead
     */
    'subtitle'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TextRead
     */
    'levels': Array<string>;
    /**
     * Default structure level for the client to use for browsing this text
     * @type {number}
     * @memberof TextRead
     */
    'defaultLevel'?: number;
    /**
     * Delimiter for displaying text locations
     * @type {string}
     * @memberof TextRead
     */
    'locDelim'?: string;
    /**
     * Whether the UI should label the nodes of the browse location with each levels\' names
     * @type {boolean}
     * @memberof TextRead
     */
    'labeledLevels'?: boolean;
    /**
     * Accent color used for this text in the client UI
     * @type {string}
     * @memberof TextRead
     */
    'accentColor'?: string;
}
/**
 * A text represented in Tekst
 * @export
 * @interface TextUpdate
 */
export interface TextUpdate {
    /**
     * 
     * @type {string}
     * @memberof TextUpdate
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof TextUpdate
     */
    'slug'?: string;
    /**
     * 
     * @type {string}
     * @memberof TextUpdate
     */
    'subtitle'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof TextUpdate
     */
    'levels'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof TextUpdate
     */
    'defaultLevel'?: number;
    /**
     * 
     * @type {string}
     * @memberof TextUpdate
     */
    'locDelim'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof TextUpdate
     */
    'labeledLevels'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TextUpdate
     */
    'accentColor'?: string;
}
/**
 * Dataset for creating a new user
 * @export
 * @interface UserCreate
 */
export interface UserCreate {
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'email': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'password': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreate
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreate
     */
    'isSuperuser'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserCreate
     */
    'isVerified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserCreate
     */
    'affiliation': string;
    /**
     * Data fields set public by this user
     * @type {Array<string>}
     * @memberof UserCreate
     */
    'publicFields'?: Array<UserCreatePublicFieldsEnum>;
}

export const UserCreatePublicFieldsEnum = {
    Username: 'username',
    Email: 'email',
    FirstName: 'firstName',
    LastName: 'lastName',
    Affiliation: 'affiliation'
} as const;

export type UserCreatePublicFieldsEnum = typeof UserCreatePublicFieldsEnum[keyof typeof UserCreatePublicFieldsEnum];

/**
 * A user registered in the system
 * @export
 * @interface UserRead
 */
export interface UserRead {
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'email': string;
    /**
     * 
     * @type {boolean}
     * @memberof UserRead
     */
    'isActive': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRead
     */
    'isSuperuser': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserRead
     */
    'isVerified': boolean;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'firstName': string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'lastName': string;
    /**
     * 
     * @type {string}
     * @memberof UserRead
     */
    'affiliation': string;
    /**
     * Data fields set public by this user
     * @type {Array<string>}
     * @memberof UserRead
     */
    'publicFields'?: Array<UserReadPublicFieldsEnum>;
}

export const UserReadPublicFieldsEnum = {
    Username: 'username',
    Email: 'email',
    FirstName: 'firstName',
    LastName: 'lastName',
    Affiliation: 'affiliation'
} as const;

export type UserReadPublicFieldsEnum = typeof UserReadPublicFieldsEnum[keyof typeof UserReadPublicFieldsEnum];

/**
 * 
 * @export
 * @interface UserReadPublic
 */
export interface UserReadPublic {
    /**
     * 
     * @type {string}
     * @memberof UserReadPublic
     */
    'username': string;
    /**
     * 
     * @type {string}
     * @memberof UserReadPublic
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserReadPublic
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserReadPublic
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserReadPublic
     */
    'affiliation'?: string;
}
/**
 * Updates to a user registered in the system
 * @export
 * @interface UserUpdate
 */
export interface UserUpdate {
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'password'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'isActive'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'isSuperuser'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserUpdate
     */
    'isVerified'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserUpdate
     */
    'affiliation'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserUpdate
     */
    'publicFields'?: Array<UserUpdatePublicFieldsEnum>;
}

export const UserUpdatePublicFieldsEnum = {
    Username: 'username',
    Email: 'email',
    FirstName: 'firstName',
    LastName: 'lastName',
    Affiliation: 'affiliation'
} as const;

export type UserUpdatePublicFieldsEnum = typeof UserUpdatePublicFieldsEnum[keyof typeof UserUpdatePublicFieldsEnum];

/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * AdminApi - axios parameter creator
 * @export
 */
export const AdminApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Hello admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloAdmin: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/admin`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminApi - functional programming interface
 * @export
 */
export const AdminApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Hello admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async helloAdmin(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.helloAdmin(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AdminApi - factory interface
 * @export
 */
export const AdminApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminApiFp(configuration)
    return {
        /**
         * 
         * @summary Hello admin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helloAdmin(options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.helloAdmin(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminApi - object-oriented interface
 * @export
 * @class AdminApi
 * @extends {BaseAPI}
 */
export class AdminApi extends BaseAPI {
    /**
     * 
     * @summary Hello admin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminApi
     */
    public helloAdmin(options?: AxiosRequestConfig) {
        return AdminApiFp(this.configuration).helloAdmin(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCookieLogin: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('authCookieLogin', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('authCookieLogin', 'password', password)
            const localVarPath = `/auth/cookie/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCookieLogout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/cookie/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtLogin: async (username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('authJwtLogin', 'username', username)
            // verify required parameter 'password' is not null or undefined
            assertParamExists('authJwtLogin', 'password', password)
            const localVarPath = `/auth/jwt/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new URLSearchParams();


            if (grantType !== undefined) { 
                localVarFormParams.set('grant_type', grantType as any);
            }
    
            if (username !== undefined) { 
                localVarFormParams.set('username', username as any);
            }
    
            if (password !== undefined) { 
                localVarFormParams.set('password', password as any);
            }
    
            if (scope !== undefined) { 
                localVarFormParams.set('scope', scope as any);
            }
    
            if (clientId !== undefined) { 
                localVarFormParams.set('client_id', clientId as any);
            }
    
            if (clientSecret !== undefined) { 
                localVarFormParams.set('client_secret', clientSecret as any);
            }
    
    
            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';
    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = localVarFormParams.toString();

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtLogout: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/jwt/logout`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Register
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerRegister: async (userCreate: UserCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userCreate' is not null or undefined
            assertParamExists('registerRegister', 'userCreate', userCreate)
            const localVarPath = `/auth/register`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Forgot password
         * @param {BodyResetForgotPasswordAuthForgotPasswordPost} bodyResetForgotPasswordAuthForgotPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetForgotPassword: async (bodyResetForgotPasswordAuthForgotPasswordPost: BodyResetForgotPasswordAuthForgotPasswordPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyResetForgotPasswordAuthForgotPasswordPost' is not null or undefined
            assertParamExists('resetForgotPassword', 'bodyResetForgotPasswordAuthForgotPasswordPost', bodyResetForgotPasswordAuthForgotPasswordPost)
            const localVarPath = `/auth/forgot-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyResetForgotPasswordAuthForgotPasswordPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Reset password
         * @param {BodyResetResetPasswordAuthResetPasswordPost} bodyResetResetPasswordAuthResetPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetResetPassword: async (bodyResetResetPasswordAuthResetPasswordPost: BodyResetResetPasswordAuthResetPasswordPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyResetResetPasswordAuthResetPasswordPost' is not null or undefined
            assertParamExists('resetResetPassword', 'bodyResetResetPasswordAuthResetPasswordPost', bodyResetResetPasswordAuthResetPasswordPost)
            const localVarPath = `/auth/reset-password`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyResetResetPasswordAuthResetPasswordPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Request verify token
         * @param {BodyVerifyRequestTokenAuthRequestVerifyTokenPost} bodyVerifyRequestTokenAuthRequestVerifyTokenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyRequestToken: async (bodyVerifyRequestTokenAuthRequestVerifyTokenPost: BodyVerifyRequestTokenAuthRequestVerifyTokenPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyVerifyRequestTokenAuthRequestVerifyTokenPost' is not null or undefined
            assertParamExists('verifyRequestToken', 'bodyVerifyRequestTokenAuthRequestVerifyTokenPost', bodyVerifyRequestTokenAuthRequestVerifyTokenPost)
            const localVarPath = `/auth/request-verify-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyVerifyRequestTokenAuthRequestVerifyTokenPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Verify
         * @param {BodyVerifyVerifyAuthVerifyPost} bodyVerifyVerifyAuthVerifyPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyVerify: async (bodyVerifyVerifyAuthVerifyPost: BodyVerifyVerifyAuthVerifyPost, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'bodyVerifyVerifyAuthVerifyPost' is not null or undefined
            assertParamExists('verifyVerify', 'bodyVerifyVerifyAuthVerifyPost', bodyVerifyVerifyAuthVerifyPost)
            const localVarPath = `/auth/verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(bodyVerifyVerifyAuthVerifyPost, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authCookieLogin(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCookieLogin(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authCookieLogout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCookieLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Login
         * @param {string} username 
         * @param {string} password 
         * @param {string} [grantType] 
         * @param {string} [scope] 
         * @param {string} [clientId] 
         * @param {string} [clientSecret] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtLogin(username: string, password: string, grantType?: string, scope?: string, clientId?: string, clientSecret?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BearerResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwtLogin(username, password, grantType, scope, clientId, clientSecret, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authJwtLogout(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authJwtLogout(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Register
         * @param {UserCreate} userCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerRegister(userCreate: UserCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerRegister(userCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Forgot password
         * @param {BodyResetForgotPasswordAuthForgotPasswordPost} bodyResetForgotPasswordAuthForgotPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetForgotPassword(bodyResetForgotPasswordAuthForgotPasswordPost: BodyResetForgotPasswordAuthForgotPasswordPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetForgotPassword(bodyResetForgotPasswordAuthForgotPasswordPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Reset password
         * @param {BodyResetResetPasswordAuthResetPasswordPost} bodyResetResetPasswordAuthResetPasswordPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resetResetPassword(bodyResetResetPasswordAuthResetPasswordPost: BodyResetResetPasswordAuthResetPasswordPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resetResetPassword(bodyResetResetPasswordAuthResetPasswordPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Request verify token
         * @param {BodyVerifyRequestTokenAuthRequestVerifyTokenPost} bodyVerifyRequestTokenAuthRequestVerifyTokenPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyRequestToken(bodyVerifyRequestTokenAuthRequestVerifyTokenPost: BodyVerifyRequestTokenAuthRequestVerifyTokenPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyRequestToken(bodyVerifyRequestTokenAuthRequestVerifyTokenPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Verify
         * @param {BodyVerifyVerifyAuthVerifyPost} bodyVerifyVerifyAuthVerifyPost 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async verifyVerify(bodyVerifyVerifyAuthVerifyPost: BodyVerifyVerifyAuthVerifyPost, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.verifyVerify(bodyVerifyVerifyAuthVerifyPost, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * 
         * @summary Login
         * @param {AuthApiAuthCookieLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCookieLogin(requestParameters: AuthApiAuthCookieLoginRequest, options?: AxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.authCookieLogin(requestParameters.username, requestParameters.password, requestParameters.grantType, requestParameters.scope, requestParameters.clientId, requestParameters.clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCookieLogout(options?: AxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.authCookieLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Login
         * @param {AuthApiAuthJwtLoginRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtLogin(requestParameters: AuthApiAuthJwtLoginRequest, options?: AxiosRequestConfig): AxiosPromise<BearerResponse> {
            return localVarFp.authJwtLogin(requestParameters.username, requestParameters.password, requestParameters.grantType, requestParameters.scope, requestParameters.clientId, requestParameters.clientSecret, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Logout
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authJwtLogout(options?: AxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.authJwtLogout(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Register
         * @param {AuthApiRegisterRegisterRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerRegister(requestParameters: AuthApiRegisterRegisterRequest, options?: AxiosRequestConfig): AxiosPromise<UserRead> {
            return localVarFp.registerRegister(requestParameters.userCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Forgot password
         * @param {AuthApiResetForgotPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetForgotPassword(requestParameters: AuthApiResetForgotPasswordRequest, options?: AxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.resetForgotPassword(requestParameters.bodyResetForgotPasswordAuthForgotPasswordPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Reset password
         * @param {AuthApiResetResetPasswordRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resetResetPassword(requestParameters: AuthApiResetResetPasswordRequest, options?: AxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.resetResetPassword(requestParameters.bodyResetResetPasswordAuthResetPasswordPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Request verify token
         * @param {AuthApiVerifyRequestTokenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyRequestToken(requestParameters: AuthApiVerifyRequestTokenRequest, options?: AxiosRequestConfig): AxiosPromise<any> {
            return localVarFp.verifyRequestToken(requestParameters.bodyVerifyRequestTokenAuthRequestVerifyTokenPost, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Verify
         * @param {AuthApiVerifyVerifyRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        verifyVerify(requestParameters: AuthApiVerifyVerifyRequest, options?: AxiosRequestConfig): AxiosPromise<UserRead> {
            return localVarFp.verifyVerify(requestParameters.bodyVerifyVerifyAuthVerifyPost, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for authCookieLogin operation in AuthApi.
 * @export
 * @interface AuthApiAuthCookieLoginRequest
 */
export interface AuthApiAuthCookieLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthCookieLogin
     */
    readonly username: string

    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthCookieLogin
     */
    readonly password: string

    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthCookieLogin
     */
    readonly grantType?: string

    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthCookieLogin
     */
    readonly scope?: string

    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthCookieLogin
     */
    readonly clientId?: string

    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthCookieLogin
     */
    readonly clientSecret?: string
}

/**
 * Request parameters for authJwtLogin operation in AuthApi.
 * @export
 * @interface AuthApiAuthJwtLoginRequest
 */
export interface AuthApiAuthJwtLoginRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthJwtLogin
     */
    readonly username: string

    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthJwtLogin
     */
    readonly password: string

    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthJwtLogin
     */
    readonly grantType?: string

    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthJwtLogin
     */
    readonly scope?: string

    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthJwtLogin
     */
    readonly clientId?: string

    /**
     * 
     * @type {string}
     * @memberof AuthApiAuthJwtLogin
     */
    readonly clientSecret?: string
}

/**
 * Request parameters for registerRegister operation in AuthApi.
 * @export
 * @interface AuthApiRegisterRegisterRequest
 */
export interface AuthApiRegisterRegisterRequest {
    /**
     * 
     * @type {UserCreate}
     * @memberof AuthApiRegisterRegister
     */
    readonly userCreate: UserCreate
}

/**
 * Request parameters for resetForgotPassword operation in AuthApi.
 * @export
 * @interface AuthApiResetForgotPasswordRequest
 */
export interface AuthApiResetForgotPasswordRequest {
    /**
     * 
     * @type {BodyResetForgotPasswordAuthForgotPasswordPost}
     * @memberof AuthApiResetForgotPassword
     */
    readonly bodyResetForgotPasswordAuthForgotPasswordPost: BodyResetForgotPasswordAuthForgotPasswordPost
}

/**
 * Request parameters for resetResetPassword operation in AuthApi.
 * @export
 * @interface AuthApiResetResetPasswordRequest
 */
export interface AuthApiResetResetPasswordRequest {
    /**
     * 
     * @type {BodyResetResetPasswordAuthResetPasswordPost}
     * @memberof AuthApiResetResetPassword
     */
    readonly bodyResetResetPasswordAuthResetPasswordPost: BodyResetResetPasswordAuthResetPasswordPost
}

/**
 * Request parameters for verifyRequestToken operation in AuthApi.
 * @export
 * @interface AuthApiVerifyRequestTokenRequest
 */
export interface AuthApiVerifyRequestTokenRequest {
    /**
     * 
     * @type {BodyVerifyRequestTokenAuthRequestVerifyTokenPost}
     * @memberof AuthApiVerifyRequestToken
     */
    readonly bodyVerifyRequestTokenAuthRequestVerifyTokenPost: BodyVerifyRequestTokenAuthRequestVerifyTokenPost
}

/**
 * Request parameters for verifyVerify operation in AuthApi.
 * @export
 * @interface AuthApiVerifyVerifyRequest
 */
export interface AuthApiVerifyVerifyRequest {
    /**
     * 
     * @type {BodyVerifyVerifyAuthVerifyPost}
     * @memberof AuthApiVerifyVerify
     */
    readonly bodyVerifyVerifyAuthVerifyPost: BodyVerifyVerifyAuthVerifyPost
}

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * 
     * @summary Login
     * @param {AuthApiAuthCookieLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authCookieLogin(requestParameters: AuthApiAuthCookieLoginRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authCookieLogin(requestParameters.username, requestParameters.password, requestParameters.grantType, requestParameters.scope, requestParameters.clientId, requestParameters.clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authCookieLogout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authCookieLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Login
     * @param {AuthApiAuthJwtLoginRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtLogin(requestParameters: AuthApiAuthJwtLoginRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwtLogin(requestParameters.username, requestParameters.password, requestParameters.grantType, requestParameters.scope, requestParameters.clientId, requestParameters.clientSecret, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Logout
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authJwtLogout(options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authJwtLogout(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Register
     * @param {AuthApiRegisterRegisterRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public registerRegister(requestParameters: AuthApiRegisterRegisterRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).registerRegister(requestParameters.userCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Forgot password
     * @param {AuthApiResetForgotPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public resetForgotPassword(requestParameters: AuthApiResetForgotPasswordRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).resetForgotPassword(requestParameters.bodyResetForgotPasswordAuthForgotPasswordPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Reset password
     * @param {AuthApiResetResetPasswordRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public resetResetPassword(requestParameters: AuthApiResetResetPasswordRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).resetResetPassword(requestParameters.bodyResetResetPasswordAuthResetPasswordPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Request verify token
     * @param {AuthApiVerifyRequestTokenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public verifyRequestToken(requestParameters: AuthApiVerifyRequestTokenRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).verifyRequestToken(requestParameters.bodyVerifyRequestTokenAuthRequestVerifyTokenPost, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Verify
     * @param {AuthApiVerifyVerifyRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public verifyVerify(requestParameters: AuthApiVerifyVerifyRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).verifyVerify(requestParameters.bodyVerifyVerifyAuthVerifyPost, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * LayersApi - axios parameter creator
 * @export
 */
export const LayersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a PlainText data layer definition
         * @summary Create layer
         * @param {PlainTextLayerCreate} plainTextLayerCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaintextLayer: async (plainTextLayerCreate: PlainTextLayerCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'plainTextLayerCreate' is not null or undefined
            assertParamExists('createPlaintextLayer', 'plainTextLayerCreate', plainTextLayerCreate)
            const localVarPath = `/layers/plaintext`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(plainTextLayerCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all data layers matching the given criteria.  As the resulting list of data layers may contain layers of different types, the returned layer objects cannot be typed to their precise layer type.
         * @summary Find layers
         * @param {string} textId 
         * @param {number} [level] 
         * @param {string} [layerType] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLayers: async (textId: string, level?: number, layerType?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textId' is not null or undefined
            assertParamExists('findLayers', 'textId', textId)
            const localVarPath = `/layers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (textId !== undefined) {
                localVarQueryParameter['textId'] = textId;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (layerType !== undefined) {
                localVarQueryParameter['layerType'] = layerType;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get generic layer data by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenericLayerDataById: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getGenericLayerDataById', 'id', id)
            const localVarPath = `/layers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the data for a PlainText data layer
         * @summary Get layer
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaintextLayer: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlaintextLayer', 'id', id)
            const localVarPath = `/layers/plaintext/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the data for a PlainText data layer
         * @summary Update layer
         * @param {string} id 
         * @param {PlainTextLayerUpdate} plainTextLayerUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaintextLayer: async (id: string, plainTextLayerUpdate: PlainTextLayerUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePlaintextLayer', 'id', id)
            // verify required parameter 'plainTextLayerUpdate' is not null or undefined
            assertParamExists('updatePlaintextLayer', 'plainTextLayerUpdate', plainTextLayerUpdate)
            const localVarPath = `/layers/plaintext/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(plainTextLayerUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LayersApi - functional programming interface
 * @export
 */
export const LayersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LayersApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a PlainText data layer definition
         * @summary Create layer
         * @param {PlainTextLayerCreate} plainTextLayerCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaintextLayer(plainTextLayerCreate: PlainTextLayerCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlainTextLayerRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlaintextLayer(plainTextLayerCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all data layers matching the given criteria.  As the resulting list of data layers may contain layers of different types, the returned layer objects cannot be typed to their precise layer type.
         * @summary Find layers
         * @param {string} textId 
         * @param {number} [level] 
         * @param {string} [layerType] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findLayers(textId: string, level?: number, layerType?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findLayers(textId, level, layerType, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get generic layer data by id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getGenericLayerDataById(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getGenericLayerDataById(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the data for a PlainText data layer
         * @summary Get layer
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaintextLayer(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlainTextLayerRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaintextLayer(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the data for a PlainText data layer
         * @summary Update layer
         * @param {string} id 
         * @param {PlainTextLayerUpdate} plainTextLayerUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlaintextLayer(id: string, plainTextLayerUpdate: PlainTextLayerUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlainTextLayerRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlaintextLayer(id, plainTextLayerUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * LayersApi - factory interface
 * @export
 */
export const LayersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LayersApiFp(configuration)
    return {
        /**
         * Creates a PlainText data layer definition
         * @summary Create layer
         * @param {LayersApiCreatePlaintextLayerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaintextLayer(requestParameters: LayersApiCreatePlaintextLayerRequest, options?: AxiosRequestConfig): AxiosPromise<PlainTextLayerRead> {
            return localVarFp.createPlaintextLayer(requestParameters.plainTextLayerCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all data layers matching the given criteria.  As the resulting list of data layers may contain layers of different types, the returned layer objects cannot be typed to their precise layer type.
         * @summary Find layers
         * @param {LayersApiFindLayersRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findLayers(requestParameters: LayersApiFindLayersRequest, options?: AxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.findLayers(requestParameters.textId, requestParameters.level, requestParameters.layerType, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get generic layer data by id
         * @param {LayersApiGetGenericLayerDataByIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getGenericLayerDataById(requestParameters: LayersApiGetGenericLayerDataByIdRequest, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getGenericLayerDataById(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the data for a PlainText data layer
         * @summary Get layer
         * @param {LayersApiGetPlaintextLayerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaintextLayer(requestParameters: LayersApiGetPlaintextLayerRequest, options?: AxiosRequestConfig): AxiosPromise<PlainTextLayerRead> {
            return localVarFp.getPlaintextLayer(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the data for a PlainText data layer
         * @summary Update layer
         * @param {LayersApiUpdatePlaintextLayerRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaintextLayer(requestParameters: LayersApiUpdatePlaintextLayerRequest, options?: AxiosRequestConfig): AxiosPromise<PlainTextLayerRead> {
            return localVarFp.updatePlaintextLayer(requestParameters.id, requestParameters.plainTextLayerUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPlaintextLayer operation in LayersApi.
 * @export
 * @interface LayersApiCreatePlaintextLayerRequest
 */
export interface LayersApiCreatePlaintextLayerRequest {
    /**
     * 
     * @type {PlainTextLayerCreate}
     * @memberof LayersApiCreatePlaintextLayer
     */
    readonly plainTextLayerCreate: PlainTextLayerCreate
}

/**
 * Request parameters for findLayers operation in LayersApi.
 * @export
 * @interface LayersApiFindLayersRequest
 */
export interface LayersApiFindLayersRequest {
    /**
     * 
     * @type {string}
     * @memberof LayersApiFindLayers
     */
    readonly textId: string

    /**
     * 
     * @type {number}
     * @memberof LayersApiFindLayers
     */
    readonly level?: number

    /**
     * 
     * @type {string}
     * @memberof LayersApiFindLayers
     */
    readonly layerType?: string

    /**
     * 
     * @type {number}
     * @memberof LayersApiFindLayers
     */
    readonly limit?: number
}

/**
 * Request parameters for getGenericLayerDataById operation in LayersApi.
 * @export
 * @interface LayersApiGetGenericLayerDataByIdRequest
 */
export interface LayersApiGetGenericLayerDataByIdRequest {
    /**
     * 
     * @type {string}
     * @memberof LayersApiGetGenericLayerDataById
     */
    readonly id: string
}

/**
 * Request parameters for getPlaintextLayer operation in LayersApi.
 * @export
 * @interface LayersApiGetPlaintextLayerRequest
 */
export interface LayersApiGetPlaintextLayerRequest {
    /**
     * 
     * @type {string}
     * @memberof LayersApiGetPlaintextLayer
     */
    readonly id: string
}

/**
 * Request parameters for updatePlaintextLayer operation in LayersApi.
 * @export
 * @interface LayersApiUpdatePlaintextLayerRequest
 */
export interface LayersApiUpdatePlaintextLayerRequest {
    /**
     * 
     * @type {string}
     * @memberof LayersApiUpdatePlaintextLayer
     */
    readonly id: string

    /**
     * 
     * @type {PlainTextLayerUpdate}
     * @memberof LayersApiUpdatePlaintextLayer
     */
    readonly plainTextLayerUpdate: PlainTextLayerUpdate
}

/**
 * LayersApi - object-oriented interface
 * @export
 * @class LayersApi
 * @extends {BaseAPI}
 */
export class LayersApi extends BaseAPI {
    /**
     * Creates a PlainText data layer definition
     * @summary Create layer
     * @param {LayersApiCreatePlaintextLayerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayersApi
     */
    public createPlaintextLayer(requestParameters: LayersApiCreatePlaintextLayerRequest, options?: AxiosRequestConfig) {
        return LayersApiFp(this.configuration).createPlaintextLayer(requestParameters.plainTextLayerCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all data layers matching the given criteria.  As the resulting list of data layers may contain layers of different types, the returned layer objects cannot be typed to their precise layer type.
     * @summary Find layers
     * @param {LayersApiFindLayersRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayersApi
     */
    public findLayers(requestParameters: LayersApiFindLayersRequest, options?: AxiosRequestConfig) {
        return LayersApiFp(this.configuration).findLayers(requestParameters.textId, requestParameters.level, requestParameters.layerType, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get generic layer data by id
     * @param {LayersApiGetGenericLayerDataByIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayersApi
     */
    public getGenericLayerDataById(requestParameters: LayersApiGetGenericLayerDataByIdRequest, options?: AxiosRequestConfig) {
        return LayersApiFp(this.configuration).getGenericLayerDataById(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the data for a PlainText data layer
     * @summary Get layer
     * @param {LayersApiGetPlaintextLayerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayersApi
     */
    public getPlaintextLayer(requestParameters: LayersApiGetPlaintextLayerRequest, options?: AxiosRequestConfig) {
        return LayersApiFp(this.configuration).getPlaintextLayer(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the data for a PlainText data layer
     * @summary Update layer
     * @param {LayersApiUpdatePlaintextLayerRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LayersApi
     */
    public updatePlaintextLayer(requestParameters: LayersApiUpdatePlaintextLayerRequest, options?: AxiosRequestConfig) {
        return LayersApiFp(this.configuration).updatePlaintextLayer(requestParameters.id, requestParameters.plainTextLayerUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * NodesApi - axios parameter creator
 * @export
 */
export const NodesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create node
         * @param {NodeCreate} nodeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode: async (nodeCreate: NodeCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'nodeCreate' is not null or undefined
            assertParamExists('createNode', 'nodeCreate', nodeCreate)
            const localVarPath = `/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Find nodes
         * @param {string} textId 
         * @param {number} [level] 
         * @param {number} [position] 
         * @param {string} [parentId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findNodes: async (textId: string, level?: number, position?: number, parentId?: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textId' is not null or undefined
            assertParamExists('findNodes', 'textId', textId)
            const localVarPath = `/nodes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (textId !== undefined) {
                localVarQueryParameter['textId'] = textId;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (position !== undefined) {
                localVarQueryParameter['position'] = position;
            }

            if (parentId !== undefined) {
                localVarQueryParameter['parentId'] = parentId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get children
         * @param {string} id 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildren: async (id: string, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getChildren', 'id', id)
            const localVarPath = `/nodes/{id}/children`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get next
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNext: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNext', 'id', id)
            const localVarPath = `/nodes/{id}/next`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get node
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getNode', 'id', id)
            const localVarPath = `/nodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the text node path from the node with the given ID as the last element, up to its most distant ancestor node on structure level 0 as the first element of an array.
         * @summary Get path by head id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPathByHeadId: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPathByHeadId', 'id', id)
            const localVarPath = `/nodes/{id}/path`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the text node path from the node with the given level/position as the last element, up to its most distant ancestor node on structure level 0 as the first element of an array.
         * @summary Get path by head location
         * @param {string} textId 
         * @param {number} level 
         * @param {number} position 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPathByHeadLocation: async (textId: string, level: number, position: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textId' is not null or undefined
            assertParamExists('getPathByHeadLocation', 'textId', textId)
            // verify required parameter 'level' is not null or undefined
            assertParamExists('getPathByHeadLocation', 'level', level)
            // verify required parameter 'position' is not null or undefined
            assertParamExists('getPathByHeadLocation', 'position', position)
            const localVarPath = `/nodes/path`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (textId !== undefined) {
                localVarQueryParameter['textId'] = textId;
            }

            if (level !== undefined) {
                localVarQueryParameter['level'] = level;
            }

            if (position !== undefined) {
                localVarQueryParameter['position'] = position;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the options for selecting text locations derived from the node path of the node with the given ID as head.
         * @summary Get path options by head id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPathOptionsByHeadId: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPathOptionsByHeadId', 'id', id)
            const localVarPath = `/nodes/{id}/path/options-by-head`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the options for selecting text locations derived from the node path of the node with the given ID as root. At each level, the first option is taken as the basis for the next level.
         * @summary Get path options by root id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPathOptionsByRootId: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPathOptionsByRootId', 'id', id)
            const localVarPath = `/nodes/{id}/path/options-by-root`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update node
         * @param {string} id 
         * @param {NodeUpdate} nodeUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNode: async (id: string, nodeUpdate: NodeUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateNode', 'id', id)
            // verify required parameter 'nodeUpdate' is not null or undefined
            assertParamExists('updateNode', 'nodeUpdate', nodeUpdate)
            const localVarPath = `/nodes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(nodeUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * NodesApi - functional programming interface
 * @export
 */
export const NodesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = NodesApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create node
         * @param {NodeCreate} nodeCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createNode(nodeCreate: NodeCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createNode(nodeCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Find nodes
         * @param {string} textId 
         * @param {number} [level] 
         * @param {number} [position] 
         * @param {string} [parentId] 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findNodes(textId: string, level?: number, position?: number, parentId?: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findNodes(textId, level, position, parentId, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get children
         * @param {string} id 
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChildren(id: string, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChildren(id, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get next
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNext(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNext(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get node
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNode(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNode(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the text node path from the node with the given ID as the last element, up to its most distant ancestor node on structure level 0 as the first element of an array.
         * @summary Get path by head id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPathByHeadId(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPathByHeadId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the text node path from the node with the given level/position as the last element, up to its most distant ancestor node on structure level 0 as the first element of an array.
         * @summary Get path by head location
         * @param {string} textId 
         * @param {number} level 
         * @param {number} position 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPathByHeadLocation(textId: string, level: number, position: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<NodeRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPathByHeadLocation(textId, level, position, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the options for selecting text locations derived from the node path of the node with the given ID as head.
         * @summary Get path options by head id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPathOptionsByHeadId(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<NodeRead>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPathOptionsByHeadId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the options for selecting text locations derived from the node path of the node with the given ID as root. At each level, the first option is taken as the basis for the next level.
         * @summary Get path options by root id
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPathOptionsByRootId(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Array<NodeRead>>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPathOptionsByRootId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update node
         * @param {string} id 
         * @param {NodeUpdate} nodeUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateNode(id: string, nodeUpdate: NodeUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NodeRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateNode(id, nodeUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * NodesApi - factory interface
 * @export
 */
export const NodesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = NodesApiFp(configuration)
    return {
        /**
         * 
         * @summary Create node
         * @param {NodesApiCreateNodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createNode(requestParameters: NodesApiCreateNodeRequest, options?: AxiosRequestConfig): AxiosPromise<NodeRead> {
            return localVarFp.createNode(requestParameters.nodeCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Find nodes
         * @param {NodesApiFindNodesRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findNodes(requestParameters: NodesApiFindNodesRequest, options?: AxiosRequestConfig): AxiosPromise<Array<NodeRead>> {
            return localVarFp.findNodes(requestParameters.textId, requestParameters.level, requestParameters.position, requestParameters.parentId, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get children
         * @param {NodesApiGetChildrenRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChildren(requestParameters: NodesApiGetChildrenRequest, options?: AxiosRequestConfig): AxiosPromise<Array<NodeRead>> {
            return localVarFp.getChildren(requestParameters.id, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get next
         * @param {NodesApiGetNextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNext(requestParameters: NodesApiGetNextRequest, options?: AxiosRequestConfig): AxiosPromise<NodeRead> {
            return localVarFp.getNext(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get node
         * @param {NodesApiGetNodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNode(requestParameters: NodesApiGetNodeRequest, options?: AxiosRequestConfig): AxiosPromise<NodeRead> {
            return localVarFp.getNode(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the text node path from the node with the given ID as the last element, up to its most distant ancestor node on structure level 0 as the first element of an array.
         * @summary Get path by head id
         * @param {NodesApiGetPathByHeadIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPathByHeadId(requestParameters: NodesApiGetPathByHeadIdRequest, options?: AxiosRequestConfig): AxiosPromise<Array<NodeRead>> {
            return localVarFp.getPathByHeadId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the text node path from the node with the given level/position as the last element, up to its most distant ancestor node on structure level 0 as the first element of an array.
         * @summary Get path by head location
         * @param {NodesApiGetPathByHeadLocationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPathByHeadLocation(requestParameters: NodesApiGetPathByHeadLocationRequest, options?: AxiosRequestConfig): AxiosPromise<Array<NodeRead>> {
            return localVarFp.getPathByHeadLocation(requestParameters.textId, requestParameters.level, requestParameters.position, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the options for selecting text locations derived from the node path of the node with the given ID as head.
         * @summary Get path options by head id
         * @param {NodesApiGetPathOptionsByHeadIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPathOptionsByHeadId(requestParameters: NodesApiGetPathOptionsByHeadIdRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Array<NodeRead>>> {
            return localVarFp.getPathOptionsByHeadId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the options for selecting text locations derived from the node path of the node with the given ID as root. At each level, the first option is taken as the basis for the next level.
         * @summary Get path options by root id
         * @param {NodesApiGetPathOptionsByRootIdRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPathOptionsByRootId(requestParameters: NodesApiGetPathOptionsByRootIdRequest, options?: AxiosRequestConfig): AxiosPromise<Array<Array<NodeRead>>> {
            return localVarFp.getPathOptionsByRootId(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update node
         * @param {NodesApiUpdateNodeRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateNode(requestParameters: NodesApiUpdateNodeRequest, options?: AxiosRequestConfig): AxiosPromise<NodeRead> {
            return localVarFp.updateNode(requestParameters.id, requestParameters.nodeUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createNode operation in NodesApi.
 * @export
 * @interface NodesApiCreateNodeRequest
 */
export interface NodesApiCreateNodeRequest {
    /**
     * 
     * @type {NodeCreate}
     * @memberof NodesApiCreateNode
     */
    readonly nodeCreate: NodeCreate
}

/**
 * Request parameters for findNodes operation in NodesApi.
 * @export
 * @interface NodesApiFindNodesRequest
 */
export interface NodesApiFindNodesRequest {
    /**
     * 
     * @type {string}
     * @memberof NodesApiFindNodes
     */
    readonly textId: string

    /**
     * 
     * @type {number}
     * @memberof NodesApiFindNodes
     */
    readonly level?: number

    /**
     * 
     * @type {number}
     * @memberof NodesApiFindNodes
     */
    readonly position?: number

    /**
     * 
     * @type {string}
     * @memberof NodesApiFindNodes
     */
    readonly parentId?: string

    /**
     * 
     * @type {number}
     * @memberof NodesApiFindNodes
     */
    readonly limit?: number
}

/**
 * Request parameters for getChildren operation in NodesApi.
 * @export
 * @interface NodesApiGetChildrenRequest
 */
export interface NodesApiGetChildrenRequest {
    /**
     * 
     * @type {string}
     * @memberof NodesApiGetChildren
     */
    readonly id: string

    /**
     * 
     * @type {number}
     * @memberof NodesApiGetChildren
     */
    readonly limit?: number
}

/**
 * Request parameters for getNext operation in NodesApi.
 * @export
 * @interface NodesApiGetNextRequest
 */
export interface NodesApiGetNextRequest {
    /**
     * 
     * @type {string}
     * @memberof NodesApiGetNext
     */
    readonly id: string
}

/**
 * Request parameters for getNode operation in NodesApi.
 * @export
 * @interface NodesApiGetNodeRequest
 */
export interface NodesApiGetNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof NodesApiGetNode
     */
    readonly id: string
}

/**
 * Request parameters for getPathByHeadId operation in NodesApi.
 * @export
 * @interface NodesApiGetPathByHeadIdRequest
 */
export interface NodesApiGetPathByHeadIdRequest {
    /**
     * 
     * @type {string}
     * @memberof NodesApiGetPathByHeadId
     */
    readonly id: string
}

/**
 * Request parameters for getPathByHeadLocation operation in NodesApi.
 * @export
 * @interface NodesApiGetPathByHeadLocationRequest
 */
export interface NodesApiGetPathByHeadLocationRequest {
    /**
     * 
     * @type {string}
     * @memberof NodesApiGetPathByHeadLocation
     */
    readonly textId: string

    /**
     * 
     * @type {number}
     * @memberof NodesApiGetPathByHeadLocation
     */
    readonly level: number

    /**
     * 
     * @type {number}
     * @memberof NodesApiGetPathByHeadLocation
     */
    readonly position: number
}

/**
 * Request parameters for getPathOptionsByHeadId operation in NodesApi.
 * @export
 * @interface NodesApiGetPathOptionsByHeadIdRequest
 */
export interface NodesApiGetPathOptionsByHeadIdRequest {
    /**
     * 
     * @type {string}
     * @memberof NodesApiGetPathOptionsByHeadId
     */
    readonly id: string
}

/**
 * Request parameters for getPathOptionsByRootId operation in NodesApi.
 * @export
 * @interface NodesApiGetPathOptionsByRootIdRequest
 */
export interface NodesApiGetPathOptionsByRootIdRequest {
    /**
     * 
     * @type {string}
     * @memberof NodesApiGetPathOptionsByRootId
     */
    readonly id: string
}

/**
 * Request parameters for updateNode operation in NodesApi.
 * @export
 * @interface NodesApiUpdateNodeRequest
 */
export interface NodesApiUpdateNodeRequest {
    /**
     * 
     * @type {string}
     * @memberof NodesApiUpdateNode
     */
    readonly id: string

    /**
     * 
     * @type {NodeUpdate}
     * @memberof NodesApiUpdateNode
     */
    readonly nodeUpdate: NodeUpdate
}

/**
 * NodesApi - object-oriented interface
 * @export
 * @class NodesApi
 * @extends {BaseAPI}
 */
export class NodesApi extends BaseAPI {
    /**
     * 
     * @summary Create node
     * @param {NodesApiCreateNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public createNode(requestParameters: NodesApiCreateNodeRequest, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).createNode(requestParameters.nodeCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Find nodes
     * @param {NodesApiFindNodesRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public findNodes(requestParameters: NodesApiFindNodesRequest, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).findNodes(requestParameters.textId, requestParameters.level, requestParameters.position, requestParameters.parentId, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get children
     * @param {NodesApiGetChildrenRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getChildren(requestParameters: NodesApiGetChildrenRequest, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getChildren(requestParameters.id, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get next
     * @param {NodesApiGetNextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getNext(requestParameters: NodesApiGetNextRequest, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getNext(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get node
     * @param {NodesApiGetNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getNode(requestParameters: NodesApiGetNodeRequest, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getNode(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the text node path from the node with the given ID as the last element, up to its most distant ancestor node on structure level 0 as the first element of an array.
     * @summary Get path by head id
     * @param {NodesApiGetPathByHeadIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getPathByHeadId(requestParameters: NodesApiGetPathByHeadIdRequest, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getPathByHeadId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the text node path from the node with the given level/position as the last element, up to its most distant ancestor node on structure level 0 as the first element of an array.
     * @summary Get path by head location
     * @param {NodesApiGetPathByHeadLocationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getPathByHeadLocation(requestParameters: NodesApiGetPathByHeadLocationRequest, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getPathByHeadLocation(requestParameters.textId, requestParameters.level, requestParameters.position, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the options for selecting text locations derived from the node path of the node with the given ID as head.
     * @summary Get path options by head id
     * @param {NodesApiGetPathOptionsByHeadIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getPathOptionsByHeadId(requestParameters: NodesApiGetPathOptionsByHeadIdRequest, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getPathOptionsByHeadId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the options for selecting text locations derived from the node path of the node with the given ID as root. At each level, the first option is taken as the basis for the next level.
     * @summary Get path options by root id
     * @param {NodesApiGetPathOptionsByRootIdRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public getPathOptionsByRootId(requestParameters: NodesApiGetPathOptionsByRootIdRequest, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).getPathOptionsByRootId(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update node
     * @param {NodesApiUpdateNodeRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NodesApi
     */
    public updateNode(requestParameters: NodesApiUpdateNodeRequest, options?: AxiosRequestConfig) {
        return NodesApiFp(this.configuration).updateNode(requestParameters.id, requestParameters.nodeUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * PlatformApi - axios parameter creator
 * @export
 */
export const PlatformApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Returns data the client needs to initialize
         * @summary Get platform data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformData: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/platform`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns public information on the user with the specified username
         * @summary Get public user info
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserInfo: async (username: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'username' is not null or undefined
            assertParamExists('getPublicUserInfo', 'username', username)
            const localVarPath = `/platform/user/{username}`
                .replace(`{${"username"}}`, encodeURIComponent(String(username)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns server-managed translations.
         * @summary Get translations
         * @param {string} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranslations: async (lang?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/platform/i18n`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (lang !== undefined) {
                localVarQueryParameter['lang'] = lang;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlatformApi - functional programming interface
 * @export
 */
export const PlatformApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PlatformApiAxiosParamCreator(configuration)
    return {
        /**
         * Returns data the client needs to initialize
         * @summary Get platform data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlatformData(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformData>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlatformData(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns public information on the user with the specified username
         * @summary Get public user info
         * @param {string} username 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicUserInfo(username: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserReadPublic>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicUserInfo(username, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns server-managed translations.
         * @summary Get translations
         * @param {string} [lang] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTranslations(lang?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTranslations(lang, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * PlatformApi - factory interface
 * @export
 */
export const PlatformApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PlatformApiFp(configuration)
    return {
        /**
         * Returns data the client needs to initialize
         * @summary Get platform data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlatformData(options?: AxiosRequestConfig): AxiosPromise<PlatformData> {
            return localVarFp.getPlatformData(options).then((request) => request(axios, basePath));
        },
        /**
         * Returns public information on the user with the specified username
         * @summary Get public user info
         * @param {PlatformApiGetPublicUserInfoRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicUserInfo(requestParameters: PlatformApiGetPublicUserInfoRequest, options?: AxiosRequestConfig): AxiosPromise<UserReadPublic> {
            return localVarFp.getPublicUserInfo(requestParameters.username, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns server-managed translations.
         * @summary Get translations
         * @param {PlatformApiGetTranslationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTranslations(requestParameters: PlatformApiGetTranslationsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getTranslations(requestParameters.lang, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for getPublicUserInfo operation in PlatformApi.
 * @export
 * @interface PlatformApiGetPublicUserInfoRequest
 */
export interface PlatformApiGetPublicUserInfoRequest {
    /**
     * 
     * @type {string}
     * @memberof PlatformApiGetPublicUserInfo
     */
    readonly username: string
}

/**
 * Request parameters for getTranslations operation in PlatformApi.
 * @export
 * @interface PlatformApiGetTranslationsRequest
 */
export interface PlatformApiGetTranslationsRequest {
    /**
     * 
     * @type {string}
     * @memberof PlatformApiGetTranslations
     */
    readonly lang?: string
}

/**
 * PlatformApi - object-oriented interface
 * @export
 * @class PlatformApi
 * @extends {BaseAPI}
 */
export class PlatformApi extends BaseAPI {
    /**
     * Returns data the client needs to initialize
     * @summary Get platform data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformApi
     */
    public getPlatformData(options?: AxiosRequestConfig) {
        return PlatformApiFp(this.configuration).getPlatformData(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns public information on the user with the specified username
     * @summary Get public user info
     * @param {PlatformApiGetPublicUserInfoRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformApi
     */
    public getPublicUserInfo(requestParameters: PlatformApiGetPublicUserInfoRequest, options?: AxiosRequestConfig) {
        return PlatformApiFp(this.configuration).getPublicUserInfo(requestParameters.username, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns server-managed translations.
     * @summary Get translations
     * @param {PlatformApiGetTranslationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlatformApi
     */
    public getTranslations(requestParameters: PlatformApiGetTranslationsRequest = {}, options?: AxiosRequestConfig) {
        return PlatformApiFp(this.configuration).getTranslations(requestParameters.lang, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SettingsApi - axios parameter creator
 * @export
 */
export const SettingsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Update platform settings
         * @param {PlatformSettingsUpdate} platformSettingsUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlatformSettings: async (platformSettingsUpdate: PlatformSettingsUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'platformSettingsUpdate' is not null or undefined
            assertParamExists('updatePlatformSettings', 'platformSettingsUpdate', platformSettingsUpdate)
            const localVarPath = `/settings`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(platformSettingsUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SettingsApi - functional programming interface
 * @export
 */
export const SettingsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SettingsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Update platform settings
         * @param {PlatformSettingsUpdate} platformSettingsUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlatformSettings(platformSettingsUpdate: PlatformSettingsUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlatformSettingsRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlatformSettings(platformSettingsUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SettingsApi - factory interface
 * @export
 */
export const SettingsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SettingsApiFp(configuration)
    return {
        /**
         * 
         * @summary Update platform settings
         * @param {SettingsApiUpdatePlatformSettingsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlatformSettings(requestParameters: SettingsApiUpdatePlatformSettingsRequest, options?: AxiosRequestConfig): AxiosPromise<PlatformSettingsRead> {
            return localVarFp.updatePlatformSettings(requestParameters.platformSettingsUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for updatePlatformSettings operation in SettingsApi.
 * @export
 * @interface SettingsApiUpdatePlatformSettingsRequest
 */
export interface SettingsApiUpdatePlatformSettingsRequest {
    /**
     * 
     * @type {PlatformSettingsUpdate}
     * @memberof SettingsApiUpdatePlatformSettings
     */
    readonly platformSettingsUpdate: PlatformSettingsUpdate
}

/**
 * SettingsApi - object-oriented interface
 * @export
 * @class SettingsApi
 * @extends {BaseAPI}
 */
export class SettingsApi extends BaseAPI {
    /**
     * 
     * @summary Update platform settings
     * @param {SettingsApiUpdatePlatformSettingsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SettingsApi
     */
    public updatePlatformSettings(requestParameters: SettingsApiUpdatePlatformSettingsRequest, options?: AxiosRequestConfig) {
        return SettingsApiFp(this.configuration).updatePlatformSettings(requestParameters.platformSettingsUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * TextsApi - axios parameter creator
 * @export
 */
export const TextsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create text
         * @param {TextCreate} textCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createText: async (textCreate: TextCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'textCreate' is not null or undefined
            assertParamExists('createText', 'textCreate', textCreate)
            const localVarPath = `/texts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get all texts
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTexts: async (limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/texts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get text
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getText: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getText', 'id', id)
            const localVarPath = `/texts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update text
         * @param {string} id 
         * @param {TextUpdate} textUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateText: async (id: string, textUpdate: TextUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateText', 'id', id)
            // verify required parameter 'textUpdate' is not null or undefined
            assertParamExists('updateText', 'textUpdate', textUpdate)
            const localVarPath = `/texts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(textUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextsApi - functional programming interface
 * @export
 */
export const TextsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TextsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create text
         * @param {TextCreate} textCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createText(textCreate: TextCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createText(textCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get all texts
         * @param {number} [limit] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTexts(limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<TextRead>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTexts(limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get text
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getText(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getText(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update text
         * @param {string} id 
         * @param {TextUpdate} textUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateText(id: string, textUpdate: TextUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateText(id, textUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * TextsApi - factory interface
 * @export
 */
export const TextsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TextsApiFp(configuration)
    return {
        /**
         * 
         * @summary Create text
         * @param {TextsApiCreateTextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createText(requestParameters: TextsApiCreateTextRequest, options?: AxiosRequestConfig): AxiosPromise<TextRead> {
            return localVarFp.createText(requestParameters.textCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get all texts
         * @param {TextsApiGetAllTextsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTexts(requestParameters: TextsApiGetAllTextsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<TextRead>> {
            return localVarFp.getAllTexts(requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get text
         * @param {TextsApiGetTextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getText(requestParameters: TextsApiGetTextRequest, options?: AxiosRequestConfig): AxiosPromise<TextRead> {
            return localVarFp.getText(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update text
         * @param {TextsApiUpdateTextRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateText(requestParameters: TextsApiUpdateTextRequest, options?: AxiosRequestConfig): AxiosPromise<TextRead> {
            return localVarFp.updateText(requestParameters.id, requestParameters.textUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createText operation in TextsApi.
 * @export
 * @interface TextsApiCreateTextRequest
 */
export interface TextsApiCreateTextRequest {
    /**
     * 
     * @type {TextCreate}
     * @memberof TextsApiCreateText
     */
    readonly textCreate: TextCreate
}

/**
 * Request parameters for getAllTexts operation in TextsApi.
 * @export
 * @interface TextsApiGetAllTextsRequest
 */
export interface TextsApiGetAllTextsRequest {
    /**
     * 
     * @type {number}
     * @memberof TextsApiGetAllTexts
     */
    readonly limit?: number
}

/**
 * Request parameters for getText operation in TextsApi.
 * @export
 * @interface TextsApiGetTextRequest
 */
export interface TextsApiGetTextRequest {
    /**
     * 
     * @type {string}
     * @memberof TextsApiGetText
     */
    readonly id: string
}

/**
 * Request parameters for updateText operation in TextsApi.
 * @export
 * @interface TextsApiUpdateTextRequest
 */
export interface TextsApiUpdateTextRequest {
    /**
     * 
     * @type {string}
     * @memberof TextsApiUpdateText
     */
    readonly id: string

    /**
     * 
     * @type {TextUpdate}
     * @memberof TextsApiUpdateText
     */
    readonly textUpdate: TextUpdate
}

/**
 * TextsApi - object-oriented interface
 * @export
 * @class TextsApi
 * @extends {BaseAPI}
 */
export class TextsApi extends BaseAPI {
    /**
     * 
     * @summary Create text
     * @param {TextsApiCreateTextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextsApi
     */
    public createText(requestParameters: TextsApiCreateTextRequest, options?: AxiosRequestConfig) {
        return TextsApiFp(this.configuration).createText(requestParameters.textCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get all texts
     * @param {TextsApiGetAllTextsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextsApi
     */
    public getAllTexts(requestParameters: TextsApiGetAllTextsRequest = {}, options?: AxiosRequestConfig) {
        return TextsApiFp(this.configuration).getAllTexts(requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get text
     * @param {TextsApiGetTextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextsApi
     */
    public getText(requestParameters: TextsApiGetTextRequest, options?: AxiosRequestConfig) {
        return TextsApiFp(this.configuration).getText(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update text
     * @param {TextsApiUpdateTextRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextsApi
     */
    public updateText(requestParameters: TextsApiUpdateTextRequest, options?: AxiosRequestConfig) {
        return TextsApiFp(this.configuration).updateText(requestParameters.id, requestParameters.textUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UnitsApi - axios parameter creator
 * @export
 */
export const UnitsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Creates a PlainText data layer unit
         * @summary Create unit
         * @param {PlainTextUnitCreate} plainTextUnitCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaintextUnit: async (plainTextUnitCreate: PlainTextUnitCreate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'plainTextUnitCreate' is not null or undefined
            assertParamExists('createPlaintextUnit', 'plainTextUnitCreate', plainTextUnitCreate)
            const localVarPath = `/units/plaintext`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(plainTextUnitCreate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns a list of all data layer units matching the given criteria.  As the resulting list may contain units of different types, the returned unit objects cannot be typed to their precise layer unit type.
         * @summary Find units
         * @param {Array<string>} [layerId] ID (or list of IDs) of layer(s) to return unit data for
         * @param {Array<string>} [nodeId] ID (or list of IDs) of node(s) to return unit data for
         * @param {number} [limit] Return at most &lt;limit&gt; items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUnits: async (layerId?: Array<string>, nodeId?: Array<string>, limit?: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/units/`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)

            if (layerId) {
                localVarQueryParameter['layerId'] = layerId;
            }

            if (nodeId) {
                localVarQueryParameter['nodeId'] = nodeId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Returns the data for a PlainText data layer unit
         * @summary Get unit
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaintextUnit: async (id: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlaintextUnit', 'id', id)
            const localVarPath = `/units/plaintext/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Updates the data for a PlainText data layer unit
         * @summary Update unit
         * @param {string} id 
         * @param {PlainTextUnitUpdate} plainTextUnitUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaintextUnit: async (id: string, plainTextUnitUpdate: PlainTextUnitUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePlaintextUnit', 'id', id)
            // verify required parameter 'plainTextUnitUpdate' is not null or undefined
            assertParamExists('updatePlaintextUnit', 'plainTextUnitUpdate', plainTextUnitUpdate)
            const localVarPath = `/units/plaintext/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(plainTextUnitUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UnitsApi - functional programming interface
 * @export
 */
export const UnitsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UnitsApiAxiosParamCreator(configuration)
    return {
        /**
         * Creates a PlainText data layer unit
         * @summary Create unit
         * @param {PlainTextUnitCreate} plainTextUnitCreate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaintextUnit(plainTextUnitCreate: PlainTextUnitCreate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlainTextUnitRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlaintextUnit(plainTextUnitCreate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns a list of all data layer units matching the given criteria.  As the resulting list may contain units of different types, the returned unit objects cannot be typed to their precise layer unit type.
         * @summary Find units
         * @param {Array<string>} [layerId] ID (or list of IDs) of layer(s) to return unit data for
         * @param {Array<string>} [nodeId] ID (or list of IDs) of node(s) to return unit data for
         * @param {number} [limit] Return at most &lt;limit&gt; items
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findUnits(layerId?: Array<string>, nodeId?: Array<string>, limit?: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<object>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findUnits(layerId, nodeId, limit, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Returns the data for a PlainText data layer unit
         * @summary Get unit
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaintextUnit(id: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlainTextUnitRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaintextUnit(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Updates the data for a PlainText data layer unit
         * @summary Update unit
         * @param {string} id 
         * @param {PlainTextUnitUpdate} plainTextUnitUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePlaintextUnit(id: string, plainTextUnitUpdate: PlainTextUnitUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlainTextUnitRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePlaintextUnit(id, plainTextUnitUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UnitsApi - factory interface
 * @export
 */
export const UnitsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UnitsApiFp(configuration)
    return {
        /**
         * Creates a PlainText data layer unit
         * @summary Create unit
         * @param {UnitsApiCreatePlaintextUnitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaintextUnit(requestParameters: UnitsApiCreatePlaintextUnitRequest, options?: AxiosRequestConfig): AxiosPromise<PlainTextUnitRead> {
            return localVarFp.createPlaintextUnit(requestParameters.plainTextUnitCreate, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns a list of all data layer units matching the given criteria.  As the resulting list may contain units of different types, the returned unit objects cannot be typed to their precise layer unit type.
         * @summary Find units
         * @param {UnitsApiFindUnitsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findUnits(requestParameters: UnitsApiFindUnitsRequest = {}, options?: AxiosRequestConfig): AxiosPromise<Array<object>> {
            return localVarFp.findUnits(requestParameters.layerId, requestParameters.nodeId, requestParameters.limit, options).then((request) => request(axios, basePath));
        },
        /**
         * Returns the data for a PlainText data layer unit
         * @summary Get unit
         * @param {UnitsApiGetPlaintextUnitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaintextUnit(requestParameters: UnitsApiGetPlaintextUnitRequest, options?: AxiosRequestConfig): AxiosPromise<PlainTextUnitRead> {
            return localVarFp.getPlaintextUnit(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * Updates the data for a PlainText data layer unit
         * @summary Update unit
         * @param {UnitsApiUpdatePlaintextUnitRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePlaintextUnit(requestParameters: UnitsApiUpdatePlaintextUnitRequest, options?: AxiosRequestConfig): AxiosPromise<PlainTextUnitRead> {
            return localVarFp.updatePlaintextUnit(requestParameters.id, requestParameters.plainTextUnitUpdate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for createPlaintextUnit operation in UnitsApi.
 * @export
 * @interface UnitsApiCreatePlaintextUnitRequest
 */
export interface UnitsApiCreatePlaintextUnitRequest {
    /**
     * 
     * @type {PlainTextUnitCreate}
     * @memberof UnitsApiCreatePlaintextUnit
     */
    readonly plainTextUnitCreate: PlainTextUnitCreate
}

/**
 * Request parameters for findUnits operation in UnitsApi.
 * @export
 * @interface UnitsApiFindUnitsRequest
 */
export interface UnitsApiFindUnitsRequest {
    /**
     * ID (or list of IDs) of layer(s) to return unit data for
     * @type {Array<string>}
     * @memberof UnitsApiFindUnits
     */
    readonly layerId?: Array<string>

    /**
     * ID (or list of IDs) of node(s) to return unit data for
     * @type {Array<string>}
     * @memberof UnitsApiFindUnits
     */
    readonly nodeId?: Array<string>

    /**
     * Return at most &lt;limit&gt; items
     * @type {number}
     * @memberof UnitsApiFindUnits
     */
    readonly limit?: number
}

/**
 * Request parameters for getPlaintextUnit operation in UnitsApi.
 * @export
 * @interface UnitsApiGetPlaintextUnitRequest
 */
export interface UnitsApiGetPlaintextUnitRequest {
    /**
     * 
     * @type {string}
     * @memberof UnitsApiGetPlaintextUnit
     */
    readonly id: string
}

/**
 * Request parameters for updatePlaintextUnit operation in UnitsApi.
 * @export
 * @interface UnitsApiUpdatePlaintextUnitRequest
 */
export interface UnitsApiUpdatePlaintextUnitRequest {
    /**
     * 
     * @type {string}
     * @memberof UnitsApiUpdatePlaintextUnit
     */
    readonly id: string

    /**
     * 
     * @type {PlainTextUnitUpdate}
     * @memberof UnitsApiUpdatePlaintextUnit
     */
    readonly plainTextUnitUpdate: PlainTextUnitUpdate
}

/**
 * UnitsApi - object-oriented interface
 * @export
 * @class UnitsApi
 * @extends {BaseAPI}
 */
export class UnitsApi extends BaseAPI {
    /**
     * Creates a PlainText data layer unit
     * @summary Create unit
     * @param {UnitsApiCreatePlaintextUnitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApi
     */
    public createPlaintextUnit(requestParameters: UnitsApiCreatePlaintextUnitRequest, options?: AxiosRequestConfig) {
        return UnitsApiFp(this.configuration).createPlaintextUnit(requestParameters.plainTextUnitCreate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns a list of all data layer units matching the given criteria.  As the resulting list may contain units of different types, the returned unit objects cannot be typed to their precise layer unit type.
     * @summary Find units
     * @param {UnitsApiFindUnitsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApi
     */
    public findUnits(requestParameters: UnitsApiFindUnitsRequest = {}, options?: AxiosRequestConfig) {
        return UnitsApiFp(this.configuration).findUnits(requestParameters.layerId, requestParameters.nodeId, requestParameters.limit, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Returns the data for a PlainText data layer unit
     * @summary Get unit
     * @param {UnitsApiGetPlaintextUnitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApi
     */
    public getPlaintextUnit(requestParameters: UnitsApiGetPlaintextUnitRequest, options?: AxiosRequestConfig) {
        return UnitsApiFp(this.configuration).getPlaintextUnit(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Updates the data for a PlainText data layer unit
     * @summary Update unit
     * @param {UnitsApiUpdatePlaintextUnitRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnitsApi
     */
    public updatePlaintextUnit(requestParameters: UnitsApiUpdatePlaintextUnitRequest, options?: AxiosRequestConfig) {
        return UnitsApiFp(this.configuration).updatePlaintextUnit(requestParameters.id, requestParameters.plainTextUnitUpdate, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UsersApi - axios parameter creator
 * @export
 */
export const UsersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Delete user
         * @param {any} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteUser: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersDeleteUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update me
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatchCurrentUser: async (userUpdate: UserUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('usersPatchCurrentUser', 'userUpdate', userUpdate)
            const localVarPath = `/users/me`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user
         * @param {any} id 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatchUser: async (id: any, userUpdate: UserUpdate, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersPatchUser', 'id', id)
            // verify required parameter 'userUpdate' is not null or undefined
            assertParamExists('usersPatchUser', 'userUpdate', userUpdate)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(userUpdate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user
         * @param {any} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUser: async (id: any, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('usersUser', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication APIKeyCookie required

            // authentication OAuth2PasswordBearer required
            // oauth required
            await setOAuthToObject(localVarHeaderParameter, "OAuth2PasswordBearer", [], configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UsersApi - functional programming interface
 * @export
 */
export const UsersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UsersApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Delete user
         * @param {any} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersDeleteUser(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersDeleteUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update me
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPatchCurrentUser(userUpdate: UserUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPatchCurrentUser(userUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user
         * @param {any} id 
         * @param {UserUpdate} userUpdate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersPatchUser(id: any, userUpdate: UserUpdate, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersPatchUser(id, userUpdate, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user
         * @param {any} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersUser(id: any, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserRead>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersUser(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UsersApi - factory interface
 * @export
 */
export const UsersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UsersApiFp(configuration)
    return {
        /**
         * 
         * @summary Me
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersCurrentUser(options?: AxiosRequestConfig): AxiosPromise<UserRead> {
            return localVarFp.usersCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Delete user
         * @param {UsersApiUsersDeleteUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersDeleteUser(requestParameters: UsersApiUsersDeleteUserRequest, options?: AxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.usersDeleteUser(requestParameters.id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update me
         * @param {UsersApiUsersPatchCurrentUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatchCurrentUser(requestParameters: UsersApiUsersPatchCurrentUserRequest, options?: AxiosRequestConfig): AxiosPromise<UserRead> {
            return localVarFp.usersPatchCurrentUser(requestParameters.userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user
         * @param {UsersApiUsersPatchUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersPatchUser(requestParameters: UsersApiUsersPatchUserRequest, options?: AxiosRequestConfig): AxiosPromise<UserRead> {
            return localVarFp.usersPatchUser(requestParameters.id, requestParameters.userUpdate, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user
         * @param {UsersApiUsersUserRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersUser(requestParameters: UsersApiUsersUserRequest, options?: AxiosRequestConfig): AxiosPromise<UserRead> {
            return localVarFp.usersUser(requestParameters.id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * Request parameters for usersDeleteUser operation in UsersApi.
 * @export
 * @interface UsersApiUsersDeleteUserRequest
 */
export interface UsersApiUsersDeleteUserRequest {
    /**
     * 
     * @type {any}
     * @memberof UsersApiUsersDeleteUser
     */
    readonly id: any
}

/**
 * Request parameters for usersPatchCurrentUser operation in UsersApi.
 * @export
 * @interface UsersApiUsersPatchCurrentUserRequest
 */
export interface UsersApiUsersPatchCurrentUserRequest {
    /**
     * 
     * @type {UserUpdate}
     * @memberof UsersApiUsersPatchCurrentUser
     */
    readonly userUpdate: UserUpdate
}

/**
 * Request parameters for usersPatchUser operation in UsersApi.
 * @export
 * @interface UsersApiUsersPatchUserRequest
 */
export interface UsersApiUsersPatchUserRequest {
    /**
     * 
     * @type {any}
     * @memberof UsersApiUsersPatchUser
     */
    readonly id: any

    /**
     * 
     * @type {UserUpdate}
     * @memberof UsersApiUsersPatchUser
     */
    readonly userUpdate: UserUpdate
}

/**
 * Request parameters for usersUser operation in UsersApi.
 * @export
 * @interface UsersApiUsersUserRequest
 */
export interface UsersApiUsersUserRequest {
    /**
     * 
     * @type {any}
     * @memberof UsersApiUsersUser
     */
    readonly id: any
}

/**
 * UsersApi - object-oriented interface
 * @export
 * @class UsersApi
 * @extends {BaseAPI}
 */
export class UsersApi extends BaseAPI {
    /**
     * 
     * @summary Me
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersCurrentUser(options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Delete user
     * @param {UsersApiUsersDeleteUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersDeleteUser(requestParameters: UsersApiUsersDeleteUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersDeleteUser(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update me
     * @param {UsersApiUsersPatchCurrentUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPatchCurrentUser(requestParameters: UsersApiUsersPatchCurrentUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPatchCurrentUser(requestParameters.userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user
     * @param {UsersApiUsersPatchUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersPatchUser(requestParameters: UsersApiUsersPatchUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersPatchUser(requestParameters.id, requestParameters.userUpdate, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user
     * @param {UsersApiUsersUserRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UsersApi
     */
    public usersUser(requestParameters: UsersApiUsersUserRequest, options?: AxiosRequestConfig) {
        return UsersApiFp(this.configuration).usersUser(requestParameters.id, options).then((request) => request(this.axios, this.basePath));
    }
}


